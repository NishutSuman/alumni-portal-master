// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String   @id @default(cuid())
  email             String   @unique
  passwordHash      String
  isEmailVerified   Boolean  @default(false)
  emailVerifyToken  String?
  passwordResetToken String?
  passwordResetExpires DateTime?
  isActive          Boolean  @default(true)
  deactivatedAt     DateTime?
  
  // Basic Profile Information
  fullName          String
  dateOfBirth       DateTime?
  batch             Int
  bio               String?
  profileImage      String?
  employmentStatus  EmploymentStatus @default(OPEN_TO_WORK)
  
  // Contact Information
  whatsappNumber    String?
  alternateNumber   String?
  
  // Social Links
  linkedinUrl       String?
  instagramUrl      String?
  facebookUrl       String?
  twitterUrl        String?
  youtubeUrl        String?
  portfolioUrl      String?
  
  // Privacy Settings
  isProfilePublic   Boolean  @default(true)
  showEmail         Boolean  @default(false)
  showPhone         Boolean  @default(false)
  
  // Role and Permissions
  role              UserRole @default(USER)

  // NEW MEMBERSHIP FIELDS (Add these to existing User model)
  membershipStatus        MembershipStatus @default(ACTIVE) // ACTIVE, EXPIRED, PENDING, INACTIVE
  currentMembershipYear   Int?      
  membershipPaidAt        DateTime?
  membershipExpiresAt     DateTime?
  membershipAmountPaid    Decimal?  @db.Decimal(10, 2)

   // LifeLink Fields (NEW)
  bloodGroup         BloodGroup?
  isBloodDonor       Boolean     @default(false)
  lastDonationDate   DateTime?
  totalDonations     Int         @default(0)

  
  // Timestamps
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  lastLoginAt       DateTime?
  
  // Relations
  posts             Post[]
  comments          Comment[]
  likes             Like[]
  transactions      Transaction[]
  notifications     Notification[]
  activityLogs      ActivityLog[]
  auditLogs         AuditLog[] @relation("AuditActor")
  batchAdminOf      Batch[] @relation("BatchAdmin")
  photoUploads      Photo[]
  albumsCreated     Album[] @relation("AlbumCreator")
  educationHistory  UserEducation[]
  workHistory       UserWorkExperience[]
  batch_            Batch   @relation("BatchMembers", fields: [batch], references: [year])
  addresses         UserAddress[]

  // Batch Collection Relation
  batchCollectionsCreated BatchEventCollection[] @relation("BatchCollectionCreator")
  batchCollectionsApproved BatchEventCollection[] @relation("BatchCollectionApprover")
  batchAdminPayments      BatchAdminPayment[] @relation("BatchPaymentAdmin")


  // NEW MEMBERSHIP RELATIONS (Add these to existing User model relations)
  batchMembershipSettings BatchMembershipSettings[] @relation("BatchMembershipCreator")
  globalMembershipSettings GlobalMembershipSettings[] @relation("GlobalMembershipCreator")
  batchAdminAssignments   BatchAdminAssignment[]    @relation("BatchAdminAssignments")
  assignedBatchAdmins     BatchAdminAssignment[]    @relation("BatchAdminAssigner")
  
  // Event Relations
  eventRegistrations    EventRegistration[]
  eventsCreated         Event[] @relation("EventCreator") 
  feedbackResponses     EventFeedbackResponse[]
  feedbackReminders     EventFeedbackReminder[] @relation("FeedbackReminders")

  // Approval relations (reverse side)
  approvedPosts     Post[]  @relation("PostApprover")
  approvedTransactions Transaction[] @relation("TransactionApprover")

  // Payment relation
  paymentTransactions      PaymentTransaction[]

  // CheckIn And Delivery Relations
  checkInsProcessed   EventCheckIn[]      @relation("CheckInStaff")
  deliveriesProcessed MerchandiseDelivery[] @relation("DeliveryStaff")

   // Treasury Relations 
  yearlyBalancesCreated    YearlyBalance[]     @relation("YearlyBalanceCreator")
  expensesCreated          Expense[]           @relation("ExpenseCreator") 
  expensesApproved         Expense[]           @relation("ExpenseApprover")
  collectionsCreated       ManualCollection[]  @relation("CollectionCreator")
  collectionsVerified      ManualCollection[]  @relation("CollectionVerifier")
  accountBalancesUpdated   AccountBalance[]    @relation("BalanceUpdater")

  // Poll relations
  createdPolls    Poll[]       @relation("PollCreator")
  pollVotes       PollVote[]

  // LifeLink Relations (NEW)
  donationHistory    BloodDonation[]     @relation("DonorHistory")
  bloodRequisitions  BloodRequisition[]  @relation("RequesterHistory") 
  donorNotifications DonorNotification[]
  donorResponses     DonorResponse[]

  createdTemplates    TicketTemplate[]      @relation("CreatedTemplates")
  savedFilters        TicketSavedFilter[]   @relation("SavedTicketFilters")
  bulkOperations      TicketBulkOperation[] @relation("PerformedBulkOps")
  searchHistory       TicketSearchHistory[] @relation("SearchHistory")
  quickActions        TicketQuickAction[]   @relation("QuickActions")

  // Separate Merchandise Relation
  merchandiseCreated     Merchandise[] @relation("MerchandiseCreator")
  merchandiseOrders      MerchandiseOrder[] @relation("MerchandiseOrders")  
  merchandiseCart        MerchandiseCartItem[] @relation("MerchandiseCart")

  
  createdGroups     OrganizationGroup[] @relation("GroupCreator")
  groupMemberships  GroupMember[]
  addedGroupMembers GroupMember[]       @relation("GroupMemberAdder")


createdSponsors  Sponsor[]  @relation("SponsorCreator")

// NEW TICKET RELATIONS (ADD THESE TO EXISTING USER MODEL)
  
  // User's own tickets
  tickets              Ticket[]               @relation("UserTickets")
  
  // Tickets assigned to this admin
  assignedTickets      Ticket[]               @relation("AssignedTickets")
  
  // Tickets resolved by this admin (might be different from assigned)
  resolvedTickets      Ticket[]               @relation("ResolvedTickets") 
  
  // Messages sent by this user (in any tickets)
  ticketMessages       TicketMessage[]        @relation("TicketMessages")
  
  // Files uploaded by this user
  ticketAttachments    TicketAttachment[]     @relation("TicketAttachments")

   messageReactions    TicketMessageReaction[]  @relation("MessageReactions")
  messageEdits        TicketMessageEdit[]      @relation("MessageEdits")
  messageDrafts       TicketMessageDraft[]     @relation("MessageDrafts")
  auditLogsPerformed  TicketAuditLog[]         @relation("PerformedAudits")
  
  @@index([batch])
  @@index([fullName])
  @@index([employmentStatus])
  @@index([isActive, isProfilePublic])
  @@map("users")
}

model UserAddress {
  id            String      @id @default(cuid())
  addressLine1  String
  addressLine2  String?
  city          String
  state         String
  postalCode    String
  country       String      @default("India")
  addressType   AddressType
  
  // Relations
  userId        String
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  @@unique([userId, addressType])
  @@map("user_addresses")
}

model UserEducation {
  id            String   @id @default(cuid())
  course        String   // e.g., "XII", "B.Tech", "MBA"
  stream        String?  // e.g., "PCMB", "Computer Science", "Finance"
  institution   String   // School/College/University name
  fromYear      Int
  toYear        Int?     // null for ongoing
  isOngoing     Boolean  @default(false)
  description   String?  // Additional details
  
  // Relations
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([userId])
  @@index([institution])
  @@index([fromYear, toYear])
  @@map("user_education")
}

model UserWorkExperience {
  id            String      @id @default(cuid())
  companyName   String
  jobRole       String
  companyType   CompanyType?
  workAddress   String?
  fromYear      Int
  toYear        Int?        // null for current job
  isCurrentJob  Boolean     @default(false)
  description   String?     // Job responsibilities, achievements
  
  // Relations
  userId        String
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  
  @@index([userId])
  @@index([companyName])
  @@index([fromYear, toYear])
  @@map("user_work_experience")
}

model Batch {
  id          String @id @default(cuid())
  year        Int    @unique
  name        String // e.g., "Class of 2020"
  description String?
  
  // Batch Statistics
  totalMembers Int   @default(0)
  
  // Batch Admins (2 per batch: 1 boy + 1 girl)
  admins      User[] @relation("BatchAdmin")
  
  // All members of this batch
  members     User[] @relation("BatchMembers")

  membershipSettings      BatchMembershipSettings[]
  adminAssignments        BatchAdminAssignment[]   @relation("BatchAdminAssignments")

  batchCollections        BatchEventCollection[] @relation("BatchCollections")
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([year])
  @@map("batches")
}

model BatchMembershipSettings {
  id              String   @id @default(cuid())
  batchYear       Int      
  batch           Batch    @relation(fields: [batchYear], references: [year], onDelete: Cascade)
  membershipFee   Decimal  @db.Decimal(10, 2)
  membershipYear  Int      
  isActive        Boolean  @default(true)
  description     String?
  
  // Admin tracking
  createdBy       String
  creator         User     @relation("BatchMembershipCreator", fields: [createdBy], references: [id])
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@unique([batchYear, membershipYear])
  @@index([batchYear])
  @@index([membershipYear])
  @@index([isActive])
  @@map("batch_membership_settings")
}

model GlobalMembershipSettings {
  id              String   @id @default(cuid())
  membershipFee   Decimal  @db.Decimal(10, 2)
  membershipYear  Int      
  isActive        Boolean  @default(false)
  applyToAll      Boolean  @default(false)
  description     String?
  
  // Admin tracking
  createdBy       String
  creator         User     @relation("GlobalMembershipCreator", fields: [createdBy], references: [id])
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@unique([membershipYear])
  @@index([membershipYear])
  @@index([isActive, applyToAll])
  @@map("global_membership_settings")
}

model BatchAdminAssignment {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation("BatchAdminAssignments", fields: [userId], references: [id], onDelete: Cascade)
  batchYear   Int
  batch       Batch    @relation("BatchAdminAssignments", fields: [batchYear], references: [year], onDelete: Cascade)
  
  // Assignment tracking
  assignedBy  String
  assigner    User     @relation("BatchAdminAssigner", fields: [assignedBy], references: [id])
  assignedAt  DateTime @default(now())
  isActive    Boolean  @default(true)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([userId, batchYear])
  @@index([userId])
  @@index([batchYear])
  @@index([isActive])
  @@map("batch_admin_assignments")
}


model Post {
  id          String      @id @default(cuid())
  title       String
  body        String      // Rich text content
  category    PostCategory
  heroImage   String?
  images      String[]    // Array of image URLs
  tags        String[]    // Array of user IDs mentioned
  allowComments Boolean @default(true)
  allowLikes    Boolean @default(true)
  isArchived  Boolean     @default(false)
  isPublished Boolean     @default(true)
  
  // Relations
  createdBy   String
  author      User        @relation(fields: [createdBy], references: [id])
  approvedBy  String?
  approver    User?       @relation("PostApprover", fields: [approvedBy], references: [id])
  linkedEventId String?
  linkedEvent Event?      @relation(fields: [linkedEventId], references: [id])
  
  comments    Comment[]
  likes       Like[]
  
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  @@index([createdBy])
  @@index([category])
  @@index([isPublished, isArchived])
  @@index([createdAt])
  @@map("posts")
}

model Comment {
  id            String    @id @default(cuid())
  content       String
  isEdited      Boolean   @default(false)
  
  // Relations
  postId        String
  post          Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  createdBy     String
  author        User      @relation(fields: [createdBy], references: [id])
  
  // Nested replies
  parentId      String?
  parent        Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies       Comment[] @relation("CommentReplies")
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@index([postId])
  @@index([createdBy])
  @@map("comments")
}

model Like {
  id        String   @id @default(cuid())
  
  // Relations
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  
  createdAt DateTime @default(now())
  
  @@unique([postId, userId])
  @@map("likes")
}


model Album {
  id          String   @id @default(cuid())
  name        String
  description String?
  coverImage  String?
  isArchived  Boolean  @default(false)
  
  // Relations
  createdBy   String
  creator     User     @relation("AlbumCreator", fields: [createdBy], references: [id])
  photos      Photo[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([createdBy])
  @@map("albums")
}

model Photo {
  id          String   @id @default(cuid())
  url         String
  caption     String?
  tags        String[] // Array of user IDs
  metadata    Json?    // Store EXIF data, file size, etc.
  
  // Relations
  albumId     String?
  album       Album?   @relation(fields: [albumId], references: [id])
  uploadedBy  String
  uploader    User     @relation(fields: [uploadedBy], references: [id])
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([uploadedBy])
  @@index([albumId])
  @@map("photos")
}

model Transaction {
  id            String           @id @default(cuid())
  type          TransactionType
  category      String           // e.g., "donation", "event_fee", "merchandise"
  amount        Decimal          @db.Decimal(10, 2)
  description   String
  referenceId   String?          // External payment reference
  receiptUrl    String?          // Upload receipt/invoice
  status        TransactionStatus @default(PENDING)
  
  // Relations
  userId        String?
  user          User?            @relation(fields: [userId], references: [id])
  approvedBy    String?
  approver      User?            @relation("TransactionApprover", fields: [approvedBy], references: [id])
  
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  
  @@index([userId])
  @@index([type, status])
  @@index([createdAt])
  @@map("transactions")
}

model Notification {
  id          String            @id @default(cuid())
  type        NotificationType
  title       String
  message     String
  payload     Json?             // Additional data for the notification
  isRead      Boolean           @default(false)
  
  // Relations
  userId      String
  user        User              @relation(fields: [userId], references: [id])
  
  createdAt   DateTime          @default(now())
  
  @@index([userId, isRead])
  @@index([createdAt])
  @@map("notifications")
}

model ActivityLog {
  id          String   @id @default(cuid())
  action      String   // e.g., "login", "profile_update", "post_create"
  details     Json?    // Additional context
  ipAddress   String?
  userAgent   String?
  
  // Relations
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  
  createdAt   DateTime @default(now())
  
  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("activity_logs")
}

model AuditLog {
  id          String   @id @default(cuid())
  action      String   // e.g., "user_deactivate", "transaction_approve"
  entityType  String   // e.g., "User", "Transaction"
  entityId    String
  oldValues   Json?
  newValues   Json?
  reason      String?
  
  // Relations
  actorId     String
  actor       User     @relation("AuditActor", fields: [actorId], references: [id])
  
  createdAt   DateTime @default(now())
  
  @@index([actorId])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@map("audit_logs")
}

// Event Schemas Below

model EventCategory {
  id          String   @id @default(cuid())
  name        String   @unique // "MEETINGS", "SOCIAL", "CULTURAL", "WORKSHOP"
  description String?
  isActive    Boolean  @default(true)
  
  // Relations
  events      Event[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([name])
  @@index([isActive])
  @@map("event_categories")
}

model Event {
  id                String      @id @default(cuid())
  title             String
  description       String      @db.Text
  slug              String?     @unique // For SEO-friendly URLs
  
  // Category and dates
  categoryId        String
  category          EventCategory @relation(fields: [categoryId], references: [id])
  eventDate         DateTime
  startTime         String?     // Store as "HH:MM" format
  endTime           String?     // Store as "HH:MM" format
  registrationStartDate DateTime?
  registrationEndDate   DateTime?

  defaultRegistrationMode RegistrationMode @default(INDIVIDUAL)
  
  // Location and mode
  venue             String?
  meetingLink       String?
  maxCapacity       Int?
  eventMode         EventMode   @default(PHYSICAL)
  
  // Status
  status            EventStatus @default(DRAFT)
  
  // Feature flags
  hasRegistration   Boolean     @default(true)
  hasExternalLink   Boolean     @default(false)
  externalRegistrationLink String?
  hasCustomForm     Boolean     @default(false)
  hasMeals          Boolean     @default(false)
  hasGuests         Boolean     @default(false)
  hasDonations      Boolean     @default(false)
  hasMerchandise    Boolean     @default(false)
  hasPrizes         Boolean     @default(false)
  hasSponsors       Boolean     @default(false)
  hasOrganizers     Boolean     @default(false)
  
  // Modification settings
  allowFormModification Boolean  @default(true)
  formModificationDeadlineHours Int @default(24)
  
  // Fee structure
  registrationFee   Decimal     @default(0) @db.Decimal(10, 2)
  guestFee          Decimal     @default(0) @db.Decimal(10, 2)
  
  // Images and attachments
  heroImage         String?
  images            String[]    // Array of image URLs
  
  // Relations
  createdBy         String
  creator           User        @relation("EventCreator", fields: [createdBy], references: [id])
  feedbackForm      EventFeedbackForm?
  feedbackAnalytics EventFeedbackAnalytics? @relation("FeedbackAnalytics")
  feedbackReminders EventFeedbackReminder[] @relation("FeedbackReminders")
  analytics             EventAnalytics?

  // Batch Collection Relation
  batchCollections        BatchEventCollection[] @relation("EventBatchCollections")

  // Treasury Relations (add to Event model)
  expenses         Expense[]          @relation("ExpenseEvent")
  manualCollections ManualCollection[] @relation("CollectionEvent")

  // Dashboard Privacy
  privacySettings       EventPrivacySettings?
  
  sections          EventSection[]
  form              EventForm?
  merchandise       EventMerchandise[]
  registrations     EventRegistration[]
  linkedPosts       Post[]      // Posts can be linked to events
  
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  @@index([categoryId])
  @@index([eventDate])
  @@index([status])
  @@index([createdBy])
  @@index([hasRegistration])
  @@map("events")
}

model EventSection {
  id          String            @id @default(cuid())
  eventId     String
  event       Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  sectionType EventSectionType
  title       String
  content     String            @db.Text
  orderIndex  Int               @default(0)
  isVisible   Boolean           @default(true)
  
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  
  @@index([eventId, orderIndex])
  @@index([sectionType])
  @@map("event_sections")
}

model EventForm {
  id          String            @id @default(cuid())
  eventId     String            @unique
  event       Event             @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  title       String            @default("Registration Form")
  description String?           @db.Text
  isActive    Boolean           @default(true)
  
  // Relations
  fields      EventFormField[]
  // responses   EventFormResponse[]
  
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  
  @@map("event_forms")
}

model EventFormField {
  id          String            @id @default(cuid())
  formId      String
  form        EventForm         @relation(fields: [formId], references: [id], onDelete: Cascade)
  
  fieldName   String            // Unique within form
  fieldLabel  String
  fieldType   EventFormFieldType
  options     Json?             // For SELECT, RADIO, CHECKBOX
  isRequired  Boolean           @default(false)
  orderIndex  Int               @default(0)
  validation  Json?             // Custom validation rules
  
  // Relations
  responses   EventFormResponse[]
  guestResponses EventGuestFormResponse[]

  
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  
  @@unique([formId, fieldName])
  @@index([formId, orderIndex])
  @@map("event_form_fields")
}

model EventMerchandise {
  id              String                    @id @default(cuid())
  eventId         String
  event           Event                     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  name            String
  description     String?                   @db.Text
  price           Decimal                   @db.Decimal(10, 2)
  images          String[]                  // Array of image URLs
  availableSizes  String[]                  // ["S", "M", "L", "XL", "XXL"]
  stockQuantity   Int?
  isActive        Boolean                   @default(true)
  orderIndex      Int                       @default(0)
  
  // Relations
  orders          EventMerchandiseOrder[]
  
  createdAt       DateTime                  @default(now())
  updatedAt       DateTime                  @updatedAt
  
  @@index([eventId])
  @@index([isActive])
  @@map("event_merchandise")
}

model EventRegistration {
  id                      String                    @id @default(cuid())
  eventId                 String
  event                   Event                     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId                  String
  user                    User                      @relation(fields: [userId], references: [id])
  
  registrationDate        DateTime                  @default(now())
  status                  EventRegistrationStatus   @default(CONFIRMED)
  
  // Payment information
  totalAmount             Decimal                   @default(0) @db.Decimal(10, 2)
  registrationFeePaid     Decimal                   @default(0) @db.Decimal(10, 2)
  guestFeesPaid           Decimal                   @default(0) @db.Decimal(10, 2)
  merchandiseTotal        Decimal                   @default(0) @db.Decimal(10, 2)
  donationAmount          Decimal                   @default(0) @db.Decimal(10, 2)
  cancelledTodonation     Decimal                   @default(0) @db.Decimal(10, 2)
  paymentReference        String?
  
  // Meal preferences
  mealPreference          MealPreference?
  
  // Guest information
  totalGuests             Int                       @default(0)
  activeGuests            Int                       @default(0)
  
  // Modification tracking
  lastModifiedAt          DateTime?
  modificationCount       Int                       @default(0)

   // Payment Information (Enhanced)
  paymentStatus       PaymentStatus       @default(PENDING)
  paymentTransactionId String?            
  paymentTransaction  PaymentTransaction? @relation(fields: [paymentTransactionId], references: [id])
  
  // Payment Amounts (For quick reference)
  totalAmountPaid     Decimal             @default(0) @db.Decimal(10, 2)
  lastPaymentAt       DateTime?
  
  // Relations
  guests                  EventGuest[]
  formResponses           EventFormResponse[]
  merchandiseOrders       EventMerchandiseOrder[]

  qr              RegistrationQR?
  checkIns        EventCheckIn[]
  
  createdAt               DateTime                  @default(now())
  updatedAt               DateTime                  @updatedAt
  
  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
  @@index([status])
  @@index([paymentStatus])
  @@map("event_registrations")
}

model EventGuest {
  id              String                    @id @default(cuid())
  registrationId  String
  registration    EventRegistration         @relation(fields: [registrationId], references: [id], onDelete: Cascade)
  
  name            String
  email           String?
  phone           String?
  mealPreference  MealPreference?
  feesPaid        Decimal                   @default(0) @db.Decimal(10, 2)
  status          GuestStatus               @default(ACTIVE)
  
  // Relations
  formResponses   EventGuestFormResponse[]
  
  createdAt       DateTime                  @default(now())
  updatedAt       DateTime                  @updatedAt
  
  @@index([registrationId])
  @@index([status])
  @@map("event_guests")
}

model EventFormResponse {
  id              String            @id @default(cuid())
  registrationId  String
  registration    EventRegistration @relation(fields: [registrationId], references: [id], onDelete: Cascade)
  fieldId         String
  field           EventFormField    @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  
  response        String            @db.Text
  version         Int               @default(1) // For modification tracking
  
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  
  @@unique([registrationId, fieldId])
  @@index([registrationId])
  @@map("event_form_responses")
}

model EventMerchandiseOrder {
  id              String                @id @default(cuid())
  registrationId  String
  registration    EventRegistration     @relation(fields: [registrationId], references: [id], onDelete: Cascade)
  merchandiseId   String
  merchandise     EventMerchandise      @relation(fields: [merchandiseId], references: [id], onDelete: Cascade)
  
  quantity        Int
  selectedSize    String?
  unitPrice       Decimal               @db.Decimal(10, 2)
  totalPrice      Decimal               @db.Decimal(10, 2)

  // Payment Information
  paymentStatus       PaymentStatus       @default(PENDING)
  paymentTransactionId String?           
  paymentTransaction  PaymentTransaction? @relation(fields: [paymentTransactionId], references: [id])

  delivery        MerchandiseDelivery?
  
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  
  @@index([registrationId])
  @@index([merchandiseId])
  @@map("event_merchandise_orders")
}

model EventGuestFormResponse {
  id          String          @id @default(cuid())
  guestId     String
  guest       EventGuest      @relation(fields: [guestId], references: [id], onDelete: Cascade)
  fieldId     String
  field       EventFormField  @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  
  response    String          @db.Text
  
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  
  @@unique([guestId, fieldId])
  @@map("event_guest_form_responses")
}

model EventFeedbackForm {
  id          String                    @id @default(cuid())
  eventId     String                    @unique
  event       Event                     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  title       String                    @default("Event Feedback")
  description String?                   @db.Text
  isActive    Boolean                   @default(true)

  allowAnonymous        Boolean          @default(true)
  showAfterEvent        Boolean          @default(true)
  autoSendReminders     Boolean          @default(false)
  reminderDelayHours    Int             @default(24)
  closeAfterHours       Int             @default(168) // 7 days
  completionMessage     String          @default("Thank you for your feedback!")
  
  // Relations
  fields      EventFeedbackField[]
  responses   EventFeedbackResponse[]
  analytics   EventFeedbackAnalytics? // 🆕 New relation
  reminders   EventFeedbackReminder[] // 🆕 New relation
  
  createdAt   DateTime                  @default(now())
  updatedAt   DateTime                  @updatedAt
  
  @@map("event_feedback_forms")
}

model EventFeedbackField {
  id                String                    @id @default(cuid())
  feedbackFormId    String
  feedbackForm      EventFeedbackForm         @relation(fields: [feedbackFormId], references: [id], onDelete: Cascade)
  
  fieldName         String
  fieldLabel        String
  fieldType         EventFormFieldType
  options           Json?
  isRequired        Boolean                   @default(false)
  orderIndex        Int                       @default(0)

  minValue          Int?
  maxValue          Int?
  stepValue         Int?                      @default(1)
  ratingStyle       String?                   @default("stars") // stars, numbers, emoji
  placeholder       String?
  helpText          String?
  
  // Relations
  responses         EventFeedbackResponse[]
  
  createdAt         DateTime                  @default(now())
  updatedAt         DateTime                  @updatedAt
  
  @@unique([feedbackFormId, fieldName])
  @@index([feedbackFormId, orderIndex])
  @@map("event_feedback_fields")
}

model EventFeedbackResponse {
  id                String                @id @default(cuid())
  feedbackFormId    String
  feedbackForm      EventFeedbackForm     @relation(fields: [feedbackFormId], references: [id], onDelete: Cascade)
  userId            String?
  user              User?                  @relation(fields: [userId], references: [id])
  fieldId           String
  field             EventFeedbackField    @relation(fields: [fieldId], references: [id], onDelete: Cascade)  // Make sure this line exists
  
  response          String                @db.Text

  status            FeedbackResponseStatus @default(SUBMITTED)
  isAnonymous       Boolean               @default(false)
  sentimentScore    SentimentScore?
  ipAddress         String?
  userAgent         String?
  submittedAt       DateTime?
  
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt
  
  // 🆕 Updated unique constraint to handle anonymous responses
  @@unique([feedbackFormId, userId, fieldId], name: "unique_identified_response")
  @@index([feedbackFormId])
  @@index([userId])
  @@index([isAnonymous])
  @@index([sentimentScore])
  @@map("event_feedback_responses")
}

model EventFeedbackAnalytics {
  id              String            @id @default(cuid())
  feedbackFormId  String            @unique
  feedbackForm    EventFeedbackForm @relation(fields: [feedbackFormId], references: [id], onDelete: Cascade)
  eventId         String             @unique
  event           Event             @relation("FeedbackAnalytics", fields: [eventId], references: [id], onDelete: Cascade)
  
  // Response Statistics
  totalResponses      Int             @default(0)
  anonymousResponses  Int             @default(0)
  identifiedResponses Int             @default(0)
  completionRate      Decimal         @default(0) @db.Decimal(5,2)
  
  // Sentiment Analytics
  avgSentimentScore     Decimal?        @db.Decimal(3,2)
  sentimentDistribution Json            @default("{}")
  
  // Rating Analytics
  avgRating             Decimal?        @db.Decimal(3,2)
  ratingDistribution    Json            @default("{}")
  
  // Response Time Analytics
  avgResponseTime       Int?
  fastestResponse       Int?
  slowestResponse       Int?
  
  // Engagement Analytics
  responsesByHour       Json            @default("{}")
  responsesByDay        Json            @default("{}")
  
  // Field Analytics
  fieldAnalytics        Json            @default("{}")
  
  // Cache Management
  lastCalculatedAt      DateTime        @default(now())
  isStale               Boolean         @default(false)
  
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  
  @@index([eventId])
  @@index([lastCalculatedAt])
  @@index([isStale])
  @@map("event_feedback_analytics")
}

model EventFeedbackReminder {
  id              String                @id @default(cuid())
  feedbackFormId  String
  feedbackForm    EventFeedbackForm     @relation(fields: [feedbackFormId], references: [id], onDelete: Cascade)
  userId          String
  user            User                  @relation("FeedbackReminders", fields: [userId], references: [id], onDelete: Cascade)
  eventId         String
  event           Event                 @relation("FeedbackReminders", fields: [eventId], references: [id], onDelete: Cascade)
  
  reminderType    String                @default("initial") // initial, followup
  scheduledAt     DateTime
  sentAt          DateTime?
  isCompleted     Boolean               @default(false)
  attempts        Int                   @default(0)
  
  emailSent       Boolean               @default(false)
  pushSent        Boolean               @default(false)
  
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  
  @@unique([feedbackFormId, userId, reminderType], name: "unique_user_reminder")
  @@index([feedbackFormId])
  @@index([userId])
  @@index([scheduledAt])
  @@index([isCompleted])
  @@map("event_feedback_reminders")
}
// ===============================================
// BATCH MODE COLLECTION
// ===============================================

model BatchEventCollection {
  id                String   @id @default(cuid())
  eventId          String
  batchYear        Int
  targetAmount     Decimal  @db.Decimal(10, 2)
  collectedAmount  Decimal  @default(0) @db.Decimal(10, 2)
  isTargetMet      Boolean  @default(false)
  isApproved       Boolean  @default(false)
  approvedBy       String?
  approvedAt       DateTime?
  registrationMode String   @default("BATCH_COLLECTION")
  status           String   @default("ACTIVE")
  description      String?
  createdBy        String
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  event            Event     @relation("EventBatchCollections", fields: [eventId], references: [id], onDelete: Cascade)
  batch            Batch     @relation("BatchCollections", fields: [batchYear], references: [year])
  creator          User      @relation("BatchCollectionCreator", fields: [createdBy], references: [id])
  approver         User?     @relation("BatchCollectionApprover", fields: [approvedBy], references: [id])
  payments         BatchAdminPayment[]

  @@unique([eventId, batchYear])
  @@index([eventId])
  @@index([batchYear])
  @@index([status])
  @@map("batch_event_collections")
}

model BatchAdminPayment {
  id                    String    @id @default(cuid())
  batchCollectionId     String
  paidByAdmin          String
  amount               Decimal   @db.Decimal(10, 2)
  paymentTransactionId String?
  paymentStatus        String    @default("PENDING")
  paymentDate          DateTime?
  notes                String?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  // Relations
  batchCollection      BatchEventCollection @relation(fields: [batchCollectionId], references: [id], onDelete: Cascade)
  admin                User                 @relation("BatchPaymentAdmin", fields: [paidByAdmin], references: [id])
  paymentTransaction   PaymentTransaction?  @relation("BatchAdminPayments", fields: [paymentTransactionId], references: [id])

  @@index([batchCollectionId])
  @@index([paidByAdmin])
  @@index([paymentStatus])
  @@map("batch_admin_payments")
}

// Payment Models

model PaymentTransaction {
  id                  String              @id @default(cuid())
  
  // Payment Identification
  transactionNumber   String              @unique
  razorpayOrderId     String?             @unique
  razorpayPaymentId   String?             @unique
  
  // Transaction Details
  amount              Decimal             @db.Decimal(12, 2)
  currency            String              @default("INR")
  description         String
  
  // Reference Information
  referenceType       PaymentReferenceType
  referenceId         String
  
  // Payment Breakdown
  breakdown           Json
  
  // Payment Provider Information
  provider            PaymentProvider      @default(RAZORPAY)
  providerOrderData   Json?
  providerPaymentData Json?
  
  // Status and Timestamps
  status              PaymentStatus        @default(PENDING)
  initiatedAt         DateTime             @default(now())
  completedAt         DateTime?
  expiresAt           DateTime?
  
  // User Information
  userId              String
  user                User                 @relation(fields: [userId], references: [id])
  
  // Metadata
  metadata            Json?
  notes               String?
  
  // Relations
  webhooks            PaymentWebhook[]
  invoices            PaymentInvoice[]
  eventRegistrations  EventRegistration[]
  merchandiseOrders   EventMerchandiseOrder[]

  batchAdminPayments      BatchAdminPayment[] @relation("BatchAdminPayments")

  merchandisePayments    MerchandiseOrder[] @relation("MerchandisePayments")
  
  // Timestamps
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  
  @@index([userId])
  @@index([status])
  @@index([referenceType, referenceId])
  @@index([provider, razorpayOrderId])
  @@index([transactionNumber])
  @@index([createdAt])
  @@map("payment_transactions")
}

model PaymentWebhook {
  id                  String              @id @default(cuid())
  
  // Webhook Identification
  provider            PaymentProvider
  eventType           String
  eventId             String?
  
  // Transaction Reference
  transactionId       String?
  transaction         PaymentTransaction? @relation(fields: [transactionId], references: [id])
  
  // Webhook Data
  rawPayload          Json
  signature           String
  isSignatureValid    Boolean             @default(false)
  
  // Processing Status
  status              WebhookStatus       @default(RECEIVED)
  processedAt         DateTime?
  errorMessage        String?
  retryCount          Int                 @default(0)
  
  // Request Information
  headers             Json?
  ipAddress           String?
  userAgent           String?
  
  // Timestamps
  receivedAt          DateTime            @default(now())
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  
  @@index([provider, eventType])
  @@index([transactionId])
  @@index([status])
  @@index([receivedAt])
  @@map("payment_webhooks")
}

model PaymentInvoice {
  id                  String              @id @default(cuid())
  
  // Invoice Identification
  invoiceNumber       String              @unique
  
  // Transaction Reference
  transactionId       String              @unique
  transaction         PaymentTransaction  @relation(fields: [transactionId], references: [id])
  
  // Invoice Data
  invoiceData         Json
  
  // PDF Management
  pdfUrl              String?
  pdfGeneratedAt      DateTime?
  
  // Email Management
  emailSentTo         String?
  emailSentAt         DateTime?
  emailResendCount    Int                 @default(0)
  
  // Status
  status              InvoiceStatus       @default(PENDING)
  
  // Timestamps
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  
  @@index([invoiceNumber])
  @@index([transactionId])
  @@index([status])
  @@index([createdAt])
  @@map("payment_invoices")
}

model EventAnalytics {
  id                    String   @id @default(cuid())
  eventId               String   @unique
  event                 Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  // Revenue Analytics
  totalRevenue          Decimal  @default(0) @db.Decimal(10, 2)
  registrationRevenue   Decimal  @default(0) @db.Decimal(10, 2)
  merchandiseRevenue    Decimal  @default(0) @db.Decimal(10, 2)
  donationRevenue       Decimal  @default(0) @db.Decimal(10, 2)
  
  // Participation Analytics
  totalRegistrations    Int      @default(0)
  confirmedRegistrations Int     @default(0)
  cancelledRegistrations Int     @default(0)
  totalGuests           Int      @default(0)
  
  // Performance Metrics
  conversionRate        Decimal? @db.Decimal(5, 2) // Registration rate
  averageOrderValue     Decimal? @db.Decimal(10, 2)
  feedbackScore         Decimal? @db.Decimal(3, 2) // Average feedback rating
  
  // Timestamps
  calculatedAt          DateTime @default(now())
  lastUpdated          DateTime @updatedAt
  
  @@index([eventId])
  @@index([calculatedAt])
  @@map("event_analytics")
}

model SystemMetrics {
  id                    String   @id @default(cuid())
  
  // System-wide totals
  totalEvents           Int      @default(0)
  totalUsers            Int      @default(0)
  totalRevenue          Decimal  @default(0) @db.Decimal(12, 2)
  totalRegistrations    Int      @default(0)
  
  // Monthly growth rates  
  monthlyEventGrowth    Decimal? @db.Decimal(5, 2)
  monthlyUserGrowth     Decimal? @db.Decimal(5, 2)
  monthlyRevenueGrowth  Decimal? @db.Decimal(5, 2)
  
  // Batch participation data
  batchWiseStats        Json?    // { "2020": { users: 50, participation: 85% }, ... }
  
  // Calculated date range
  periodStart           DateTime
  periodEnd             DateTime
  metricsDate           DateTime @default(now())
  
  @@index([metricsDate])
  @@map("system_metrics")
}

// ==========================================
// QR CODE & CHECK-IN MODELS (Phase 7B)
// ==========================================

model RegistrationQR {
  id              String            @id @default(cuid())
  registrationId  String            @unique
  registration    EventRegistration @relation(fields: [registrationId], references: [id], onDelete: Cascade)
  
  // QR Code Data
  qrCode          String            @unique // Generated QR code hash
  qrData          Json              // Complete registration data (user + guests + merchandise)
  qrImageUrl      String?           // URL to QR code image (if stored)
  
  // Metadata
  generatedAt     DateTime          @default(now())
  lastScannedAt   DateTime?
  scanCount       Int               @default(0)
  isActive        Boolean           @default(true)
  expiresAt       DateTime?         // Optional expiration
  
  // Relations
  checkIns        EventCheckIn[]
  
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  
  @@index([qrCode])
  @@index([registrationId])
  @@index([isActive])
  @@map("registration_qr")
}

model EventCheckIn {
  id              String            @id @default(cuid())
  registrationId  String
  registration    EventRegistration @relation(fields: [registrationId], references: [id], onDelete: Cascade)
  qrId            String?
  qr              RegistrationQR?   @relation(fields: [qrId], references: [id])
  
  // Check-in Details
  checkedInAt     DateTime          @default(now())
  checkedInBy     String?           // Admin/Staff user ID who processed check-in
  checkedInStaff  User?             @relation("CheckInStaff", fields: [checkedInBy], references: [id])
  
  // Guest Check-in Info
  guestsCheckedIn Int               @default(0)
  totalGuests     Int               @default(0)
  guestDetails    Json?             // Which specific guests were checked in
  
  // Additional Info
  checkInLocation String?           // Venue/Gate location
  notes           String?           @db.Text
  checkInMethod   CheckInMethod     @default(QR_CODE)
  
  // Verification
  isVerified      Boolean           @default(true)
  verificationNotes String?
  
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  
  @@index([registrationId])
  @@index([checkedInAt])
  @@index([checkedInBy])
  @@map("event_check_ins")
}

model MerchandiseDelivery {
  id                String                @id @default(cuid())
  orderId           String                @unique
  order             EventMerchandiseOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  // Delivery Details
  deliveredAt       DateTime              @default(now())
  deliveredBy       String                // Staff/Admin user ID
  deliveryStaff     User                  @relation("DeliveryStaff", fields: [deliveredBy], references: [id])
  
  // Delivery Information
  deliveryNotes     String?               @db.Text
  confirmationPhoto String?               // Photo URL as confirmation
  recipientName     String                // Who received the item
  deliveryLocation  String?               // Where it was delivered
  
  // Status tracking
  status            DeliveryStatus        @default(DELIVERED)
  
  createdAt         DateTime              @default(now())
  updatedAt         DateTime              @updatedAt
  
  @@index([orderId])
  @@index([deliveredBy])
  @@index([deliveredAt])
  @@map("merchandise_deliveries")
}

// ==========================================
// REGISTRATION DASHBOARD MODELS (Phase 7D)
// ==========================================

model EventPrivacySettings {
  id                    String  @id @default(cuid())
  eventId               String  @unique
  event                 Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  // Public Visibility Controls
  showPaymentAmounts    Boolean @default(false)  // Admin toggle: show payment amounts to public
  showDonationAmounts   Boolean @default(false)  // Admin toggle: show donations to public
  showUserEmails        Boolean @default(false)  // Admin toggle: show emails to public
  showUserPhones        Boolean @default(false)  // Admin toggle: show phone numbers to public
  showGuestDetails      Boolean @default(true)   // Admin toggle: show guest names to public
  showBatchInfo         Boolean @default(true)   // Admin toggle: show batch year to public
  showRegistrationDate  Boolean @default(true)   // Admin toggle: show registration dates to public
  
  // Dashboard Configuration
  enablePublicDashboard Boolean @default(true)   // Admin toggle: enable/disable public dashboard
  dashboardTitle        String? @default("Event Registrations")
  dashboardMessage      String? // Custom message for public dashboard
  
  // Statistics Visibility
  showTotalCount        Boolean @default(true)   // Show total registration count
  showBatchStats        Boolean @default(true)   // Show batch-wise breakdown
  showPaymentStats      Boolean @default(false)  // Show payment completion stats
  
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt
  
  @@index([eventId])
  @@map("event_privacy_settings")
}


// ============================================
// TREASURY MANAGEMENT MODELS
// ============================================

model YearlyBalance {
  id             String   @id @default(cuid())
  year           Int      @unique
  openingBalance Decimal  @db.Decimal(15, 2) @default(0)
  closingBalance Decimal? @db.Decimal(15, 2)
  notes          String?  @db.Text
  
  // Relations
  createdBy      String
  creator        User     @relation("YearlyBalanceCreator", fields: [createdBy], references: [id])
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  @@index([year])
  @@index([createdBy])
  @@map("yearly_balances")
}

model ExpenseCategory {
  id           String               @id @default(cuid())
  name         String               @unique
  description  String?              @db.Text
  isActive     Boolean              @default(true)
  displayOrder Int                  @default(0)
  
  // Relations
  subcategories ExpenseSubcategory[]
  expenses      Expense[]
  
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  
  @@index([name])
  @@index([isActive])
  @@index([displayOrder])
  @@map("expense_categories")
}

model ExpenseSubcategory {
  id           String          @id @default(cuid())
  name         String
  description  String?         @db.Text
  isActive     Boolean         @default(true)
  displayOrder Int             @default(0)
  
  // Relations
  categoryId   String
  category     ExpenseCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  expenses     Expense[]
  
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  
  @@unique([categoryId, name])
  @@index([categoryId])
  @@index([displayOrder])
  @@map("expense_subcategories")
}

model Expense {
  id            String              @id @default(cuid())
  amount        Decimal             @db.Decimal(12, 2)
  description   String              @db.Text
  expenseDate   DateTime
  receiptUrl    String?
  vendorName    String?
  vendorContact String?
  
  // Category Relations
  categoryId    String
  category      ExpenseCategory     @relation(fields: [categoryId], references: [id])
  subcategoryId String?
  subcategory   ExpenseSubcategory? @relation(fields: [subcategoryId], references: [id])
  
  // Event Relation (Optional)
  linkedEventId String?
  linkedEvent   Event?              @relation("ExpenseEvent", fields: [linkedEventId], references: [id])
  
  // Admin Relations
  createdBy     String
  creator       User                @relation("ExpenseCreator", fields: [createdBy], references: [id])
  approvedBy    String?
  approver      User?               @relation("ExpenseApprover", fields: [approvedBy], references: [id])
  
  isApproved    Boolean             @default(false)
  approvedAt    DateTime?
  
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  
  @@index([expenseDate])
  @@index([categoryId])
  @@index([subcategoryId])
  @@index([linkedEventId])
  @@index([createdBy])
  @@index([isApproved])
  @@map("expenses")
}

model ManualCollection {
  id             String                @id @default(cuid())
  amount         Decimal               @db.Decimal(12, 2)
  description    String                @db.Text
  collectionDate DateTime
  collectionMode ManualCollectionMode  @default(CASH)
  receiptUrl     String?
  donorName      String?
  donorContact   String?
  
  // Category (Optional)
  category       String?
  
  // Event Relation (Optional)
  linkedEventId  String?
  linkedEvent    Event?                @relation("CollectionEvent", fields: [linkedEventId], references: [id])
  
  // Admin Relations
  createdBy      String
  creator        User                  @relation("CollectionCreator", fields: [createdBy], references: [id])
  verifiedBy     String?
  verifier       User?                 @relation("CollectionVerifier", fields: [verifiedBy], references: [id])
  
  isVerified     Boolean               @default(true)
  verifiedAt     DateTime?
  
  createdAt      DateTime              @default(now())
  updatedAt      DateTime              @updatedAt
  
  @@index([collectionDate])
  @@index([collectionMode])
  @@index([linkedEventId])
  @@index([createdBy])
  @@index([category])
  @@map("manual_collections")
}

model AccountBalance {
  id               String   @id @default(cuid())
  currentBalance   Decimal  @db.Decimal(15, 2)
  balanceDate      DateTime
  notes            String?  @db.Text
  bankStatementUrl String?
  
  // Admin tracking
  updatedBy        String
  updater          User     @relation("BalanceUpdater", fields: [updatedBy], references: [id])
  
  createdAt        DateTime @default(now())
  
  @@index([balanceDate])
  @@index([updatedBy])
  @@map("account_balances")
}

// Cell/Committee/OfficeBearers model

model OrganizationGroup {
  id          String      @id @default(cuid())
  name        String      @unique
  type        GroupType   
  description String?     @db.Text
  isActive    Boolean     @default(true)
  displayOrder Int        @default(0)
  
  // Relations
  members     GroupMember[]
  createdBy   String
  creator     User        @relation("GroupCreator", fields: [createdBy], references: [id])
  
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  
  @@index([type])
  @@index([isActive])
  @@index([createdBy])
  @@map("organization_groups")
}

model GroupMember {
  id       String              @id @default(cuid())
  groupId  String
  group    OrganizationGroup   @relation(fields: [groupId], references: [id], onDelete: Cascade)
  userId   String  
  user     User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  role     GroupMemberRole
  isActive Boolean             @default(true)
  
  // Admin tracking
  addedBy  String
  adder    User                @relation("GroupMemberAdder", fields: [addedBy], references: [id])
  
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt
  
  @@unique([groupId, userId])
  @@index([groupId])
  @@index([userId])
  @@index([role])
  @@map("group_members")
}

model Sponsor {
  id            String          @id @default(cuid())
  name          String          @unique
  category      SponsorCategory
  description   String?         @db.Text
  logoUrl       String?         // Sponsor company logo
  headPhotoUrl  String?         // Photo of head of sponsor organization
  isActive      Boolean         @default(true)
  displayOrder  Int             @default(0)
  
  // Website and contact info
  website       String?
  contactEmail  String?
  
  // Admin tracking
  createdBy     String
  creator       User            @relation("SponsorCreator", fields: [createdBy], references: [id])
  
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
  
  @@index([category])
  @@index([isActive])
  @@index([displayOrder])
  @@index([createdBy])
  @@map("sponsors")
}

// ============================================
// POLL MANAGEMENT MODELS - ADD TO schema.prisma
// ============================================

// Add these new models to your schema.prisma file

model Poll {
  id              String      @id @default(cuid())
  title           String
  description     String?     @db.Text
  isActive        Boolean     @default(true)
  allowMultiple   Boolean     @default(false)  // Allow multiple option selection
  expiresAt       DateTime?   // Optional poll expiry
  isAnonymous     Boolean     @default(false)  // Hide voter names in results
  
  // Relations
  createdBy       String
  creator         User        @relation("PollCreator", fields: [createdBy], references: [id])
  options         PollOption[]
  votes           PollVote[]
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  @@index([createdBy])
  @@index([isActive])
  @@index([expiresAt])
  @@index([createdAt])
  @@map("polls")
}

model PollOption {
  id        String      @id @default(cuid())
  text      String      @db.Text
  displayOrder Int      @default(0)
  
  // Relations
  pollId    String
  poll      Poll        @relation(fields: [pollId], references: [id], onDelete: Cascade)
  votes     PollVote[]
  
  createdAt DateTime    @default(now())
  
  @@index([pollId])
  @@index([displayOrder])
  @@map("poll_options")
}

model PollVote {
  id        String      @id @default(cuid())
  
  // Relations
  pollId    String
  poll      Poll        @relation(fields: [pollId], references: [id], onDelete: Cascade)
  optionId  String
  option    PollOption  @relation(fields: [optionId], references: [id], onDelete: Cascade)
  userId    String
  user      User        @relation(fields: [userId], references: [id])
  
  createdAt DateTime    @default(now())
  
  // Prevent duplicate votes for same poll/option combination
  @@unique([pollId, userId, optionId])
  @@index([pollId])
  @@index([userId])
  @@index([optionId])
  @@map("poll_votes")
}


// ============================================
// NEW LIFELINK MODELS
// ============================================

model BloodDonation {
  id            String   @id @default(cuid())
  donationDate  DateTime
  location      String?  // Hospital/blood bank name
  units         Int      @default(1)
  notes         String?  @db.Text
  
  // Relations
  donorId       String
  donor         User     @relation("DonorHistory", fields: [donorId], references: [id])
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([donorId])
  @@index([donationDate])
  @@map("blood_donations")
}

model BloodRequisition {
  id                    String            @id @default(cuid())
  patientName           String
  hospitalName          String
  contactNumber         String
  alternateNumber       String?
  requiredBloodGroup    BloodGroup
  unitsNeeded           Int               @default(1)
  urgencyLevel          String            @default("HIGH") // HIGH, MEDIUM, LOW
  medicalCondition      String?           @db.Text
  location              String            // Area/city
  additionalNotes       String?           @db.Text
  
  // Status and timing
  status                RequisitionStatus @default(ACTIVE)
  requiredByDate        DateTime
  expiresAt             DateTime?
  
  // Contact revelation settings
  allowContactReveal    Boolean           @default(true)
  
  // Relations
  requesterId           String
  requester             User              @relation("RequesterHistory", fields: [requesterId], references: [id])
  notifications         DonorNotification[]
  responses             DonorResponse[]
  
  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt
  
  @@index([requesterId])
  @@index([requiredBloodGroup])
  @@index([status])
  @@index([location])
  @@index([requiredByDate])
  @@map("blood_requisitions")
}

model DonorNotification {
  id                String             @id @default(cuid())
  title             String
  message           String             @db.Text
  notificationType  String             @default("EMERGENCY") // EMERGENCY, REMINDER, INFO
  
  // Notification delivery
  status            NotificationStatus @default(PENDING)
  sentAt            DateTime?
  deliveredAt       DateTime?
  readAt            DateTime?
  
  // Push notification data
  pushNotificationId String?
  deviceToken       String?
  
  // Relations
  donorId           String
  donor             User               @relation(fields: [donorId], references: [id])
  requisitionId     String?
  requisition       BloodRequisition?  @relation(fields: [requisitionId], references: [id])
  
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  
  @@index([donorId])
  @@index([status])
  @@index([notificationType])
  @@index([requisitionId])
  @@map("donor_notifications")
}

model DonorResponse {
  id            String              @id @default(cuid())
  response      DonorResponseStatus @default(NO_RESPONSE)
  message       String?             @db.Text
  
  // Contact information (revealed based on privacy settings)
  contactPhone  String?
  isContactRevealed Boolean         @default(false)
  
  // Response timing
  respondedAt   DateTime?
  
  // Relations
  donorId       String
  donor         User                @relation(fields: [donorId], references: [id])
  requisitionId String
  requisition   BloodRequisition    @relation(fields: [requisitionId], references: [id])
  
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  
  @@unique([donorId, requisitionId]) // One response per donor per requisition
  @@index([donorId])
  @@index([requisitionId])
  @@index([response])
  @@map("donor_responses")
}


// Ticket Categories (for organization)
model TicketCategory {
  id          String   @id @default(cuid())
  name        String   @unique // "TECHNICAL", "ACCOUNT", "EVENT", "GENERAL", "BILLING", "LIFELINK"
  description String?
  icon        String?  // For UI display
  isActive    Boolean  @default(true)
  priority    Int      @default(0) // For sorting in UI
  
  // Relations
  tickets     Ticket[]
   templates   TicketTemplate[]
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@map("ticket_categories")
}

// Main Ticket Model
model Ticket {
  id           String        @id @default(cuid())
  ticketNumber String        @unique // Auto-generated: TKT-2025-000001
  
  // User Information
  userId       String
  user         User          @relation("UserTickets", fields: [userId], references: [id])
  
  // Admin Assignment (NEW FEATURE)
  assignedToId String?       // Admin ID selected by user
  assignedTo   User?         @relation("AssignedTickets", fields: [assignedToId], references: [id])
  assignedAt   DateTime?     // When ticket was assigned
  
  // Ticket Details
  categoryId   String
  category     TicketCategory @relation(fields: [categoryId], references: [id])
  subject      String        // 5-200 characters
  description  String        @db.Text // 10-5000 characters
  priority     TicketPriority @default(MEDIUM)
  status       TicketStatus   @default(OPEN)
  tags        String[] 

  // Template tracking
  createdFromTemplate Boolean @default(false)
  templateId          String?
  
  // Resolution Information
  resolvedAt   DateTime?
  resolvedBy   String?       // Admin who actually resolved (might be different from assigned)
  resolver     User?         @relation("ResolvedTickets", fields: [resolvedBy], references: [id])
  resolutionNote String?     @db.Text // Admin's final resolution note
  
  // User Feedback
  satisfaction TicketSatisfaction?
  satisfactionNote String?   // User's satisfaction feedback
  ratedAt      DateTime?
  
  // Tracking
  lastActivity DateTime      @default(now()) // Updated on any new message/status change
  reopenCount  Int           @default(0)

  auditLogs     TicketAuditLog[]
  messageDrafts TicketMessageDraft[]
  
  // Relations
  messages     TicketMessage[]
  attachments  TicketAttachment[]
  
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  
  // Optimized indexes for performance
  @@index([userId, status])           // User's tickets by status
  @@index([assignedToId, status])     // Admin's assigned tickets
  @@index([status, createdAt])        // All tickets by status and date
  @@index([categoryId, status])       // Tickets by category
  @@index([ticketNumber])             // Quick lookup by ticket number
  @@index([lastActivity])             // Recently active tickets
  @@index([priority, status])         // Priority-based filtering
  
  @@map("tickets")
}

// Ticket Messages (conversation thread)
model TicketMessage {
  id         String      @id @default(cuid())
  ticketId   String
  ticket     Ticket      @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  // Message Details
  senderId   String
  sender     User        @relation("TicketMessages", fields: [senderId], references: [id])
  message    String      @db.Text
  isFromAdmin Boolean    @default(false) // Auto-set based on sender role
  
  // Message Status (for read receipts)
  isRead     Boolean     @default(false)
  readAt     DateTime?
  
  // Internal Admin Notes (visible only to admins)
  isInternalNote Boolean @default(false) // Admin-to-admin communication

  // NEW FIELDS FOR PHASE 2:
  isEdited      Boolean   @default(false)
  editedAt      DateTime?
  
  // Enhanced content support
  contentType   MessageContentType @default(PLAIN_TEXT)
  formattedContent Json? // Rich text formatting data
  
  // Relations to new models
  reactions     TicketMessageReaction[]
  editHistory   TicketMessageEdit[]
  
  // Relations
  attachments TicketMessageAttachment[]
  
  createdAt  DateTime    @default(now())
  updatedAt  DateTime    @updatedAt
  
  @@index([ticketId, createdAt])  // Messages in chronological order
  @@index([senderId])             // Messages by sender
  @@index([isFromAdmin])          // Filter admin vs user messages
  
  @@map("ticket_messages")
}

// File Attachments for Initial Ticket
model TicketAttachment {
  id           String   @id @default(cuid())
  ticketId     String
  ticket       Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  // File Information
  filename     String   // Stored filename (with timestamp)
  originalName String   // Original uploaded filename
  fileSize     Int      // Size in bytes
  mimeType     String   // File MIME type
  filePath     String   // Relative path from uploads directory
  
  // Upload Information
  uploadedBy   String
  uploader     User     @relation("TicketAttachments", fields: [uploadedBy], references: [id])
  
  createdAt    DateTime @default(now())
  
  @@index([ticketId])
  @@index([uploadedBy])
  
  @@map("ticket_attachments")
}

// Message-specific Attachments
model TicketMessageAttachment {
  id           String        @id @default(cuid())
  messageId    String
  message      TicketMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  // File Information  
  filename     String
  originalName String
  fileSize     Int
  mimeType     String
  filePath     String
  
  createdAt    DateTime      @default(now())
  
  @@index([messageId])
  
  @@map("ticket_message_attachments")
}

// Message Reactions (helpful, solved, needs clarification)
model TicketMessageReaction {
  id        String        @id @default(cuid())
  messageId String
  message   TicketMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  userId    String
  user      User          @relation("MessageReactions", fields: [userId], references: [id])
  
  reaction  MessageReactionType
  
  createdAt DateTime      @default(now())
  
  @@unique([messageId, userId, reaction]) // One reaction type per user per message
  @@index([messageId])
  @@index([userId])
  @@map("ticket_message_reactions")
}

// Message Edit History (track message changes)
model TicketMessageEdit {
  id              String        @id @default(cuid())
  messageId       String
  message         TicketMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  previousContent String        @db.Text
  editReason      String?       // Optional reason for edit
  editedBy        String
  editor          User          @relation("MessageEdits", fields: [editedBy], references: [id])
  
  createdAt       DateTime      @default(now())
  
  @@index([messageId, createdAt])
  @@map("ticket_message_edits")
}

// Message Drafts (auto-save while typing)
model TicketMessageDraft {
  id        String   @id @default(cuid())
  ticketId  String
  ticket    Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  userId    String
  user      User     @relation("MessageDrafts", fields: [userId], references: [id])
  
  content   String   @db.Text
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([ticketId, userId]) // One draft per user per ticket
  @@map("ticket_message_drafts")
}

// Enhanced Audit Trail for detailed tracking
model TicketAuditLog {
  id          String          @id @default(cuid())
  ticketId    String
  ticket      Ticket          @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  // Action Details
  actionType  AuditActionType
  fieldName   String?         // Which field changed (status, priority, etc.)
  oldValue    String?         // Previous value (JSON serialized)
  newValue    String?         // New value (JSON serialized)  
  description String          // Human readable description
  
  // Actor Information
  performedBy String?
  performer   User?           @relation("PerformedAudits", fields: [performedBy], references: [id])
  isSystem    Boolean         @default(false) // System-generated vs user action
  
  // Context
  ipAddress   String?
  userAgent   String?
  metadata    Json?           // Additional context data
  
  createdAt   DateTime        @default(now())
  
  @@index([ticketId, createdAt])
  @@index([performedBy])
  @@index([actionType])
  @@map("ticket_audit_logs")
}

// Enhanced File Metadata (for better file management)
model TicketFileMetadata {
  id             String   @id @default(cuid())
  attachmentId   String   @unique
  // This can reference either TicketAttachment or TicketMessageAttachment
  
  // File Analysis
  isImage        Boolean  @default(false)
  imageWidth     Int?
  imageHeight    Int?
  thumbnailPath  String?  // Generated thumbnail path
  
  // File Properties
  compressedSize Int?     // Size after compression
  checksum       String?  // File integrity check
  
  // Access Tracking
  downloadCount  Int      @default(0)
  lastAccessed   DateTime?
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  
  @@map("ticket_file_metadata")
}

// Ticket Templates for common issues
model TicketTemplate {
  id          String         @id @default(cuid())
  name        String         // "Login Issues", "Event Registration Problem"
  description String?        // Template description
  categoryId  String
  category    TicketCategory @relation(fields: [categoryId], references: [id])
  
  // Template Content
  subjectTemplate     String          // "Unable to login - {issue_type}"
  descriptionTemplate String @db.Text // Pre-filled description with placeholders
  priorityDefault     TicketPriority  @default(MEDIUM)
  
  // Dynamic Fields Configuration
  hasCustomFields     Boolean @default(false)
  customFields        Json?   // Configuration for dynamic fields
  
  // Template Management
  isActive     Boolean @default(true)
  isPublic     Boolean @default(true)  // Public templates vs admin-only
  sortOrder    Int     @default(0)
  
  // Usage Statistics  
  usageCount   Int      @default(0)
  lastUsedAt   DateTime?
  
  // Management
  createdBy    String
  creator      User     @relation("CreatedTemplates", fields: [createdBy], references: [id])
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@index([categoryId, isActive, isPublic])
  @@index([isActive, sortOrder])
  @@map("ticket_templates")
}

// Saved Search Filters for users and admins
model TicketSavedFilter {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation("SavedTicketFilters", fields: [userId], references: [id])
  
  // Filter Details
  name        String   // "My Urgent Tickets", "This Week's Tech Issues"
  description String?
  filterConfig Json    // Serialized filter criteria
  
  // Filter Settings
  isDefault   Boolean  @default(false) // Default filter for user
  isShared    Boolean  @default(false) // Admin can share filters with all users
  shareWith   String[] // Array of user IDs to share with
  
  // Usage Stats
  usageCount  Int      @default(0)
  lastUsedAt  DateTime?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([userId, name])
  @@index([userId, isDefault])
  @@index([isShared])
  @@map("ticket_saved_filters")
}

// Bulk Operation Tracking
model TicketBulkOperation {
  id           String              @id @default(cuid())
  operationId  String              @unique // For tracking async operations
  
  // Operation Details
  operationType BulkOperationType
  description   String             // Human readable description
  targetCount   Int                // Number of tickets targeted
  successCount  Int      @default(0)
  failureCount  Int      @default(0)
  
  // Operation Data
  ticketIds     String[]           // Array of ticket IDs
  operationData Json?              // Operation parameters
  results       Json?              // Success/failure details
  
  // Status Tracking
  status        BulkOperationStatus @default(PENDING)
  startedAt     DateTime?
  completedAt   DateTime?
  failureReason String?
  
  // Actor Information
  performedBy   String
  performer     User               @relation("PerformedBulkOps", fields: [performedBy], references: [id])
  
  // Context
  ipAddress     String?
  userAgent     String?
  
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  
  @@index([performedBy, createdAt])
  @@index([status, createdAt])
  @@index([operationType])
  @@map("ticket_bulk_operations")
}

// Advanced Search History (for suggestions and analytics)
model TicketSearchHistory {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation("SearchHistory", fields: [userId], references: [id])
  
  // Search Details
  searchQuery String   // User's search terms
  searchType  SearchType @default(BASIC)
  filterConfig Json?   // Applied filters
  resultsCount Int     // Number of results returned
  
  // Usage Analytics
  clicked     Boolean  @default(false) // Did user click any results
  clickedTicketId String? // Which ticket they opened from search
  
  createdAt   DateTime @default(now())
  
  @@index([userId, createdAt])
  @@index([searchQuery])
  @@map("ticket_search_history")
}

// Quick Actions (for frequently used operations)
model TicketQuickAction {
  id          String   @id @default(cuid())
  userId      String
  user        User     @relation("QuickActions", fields: [userId], references: [id])
  
  // Action Details
  actionType  String   // "close_with_template", "assign_to_me", "priority_high"
  actionName  String   // Display name
  actionData  Json     // Action parameters
  
  // Settings
  isEnabled   Boolean  @default(true)
  sortOrder   Int      @default(0)
  
  // Usage Stats
  usageCount  Int      @default(0)
  lastUsedAt  DateTime?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([userId, actionType])
  @@index([userId, isEnabled, sortOrder])
  @@map("ticket_quick_actions")
}


//==============================
// STANDALONE MERCHANDISE SYSTEM - Not Integrated with Event
//==============================

model Merchandise {
  id              String   @id @default(cuid())
  name            String
  description     String?  @db.Text
  price           Decimal  @db.Decimal(10, 2)
  images          String[] // Array of image URLs
  availableSizes  String[] // ["S", "M", "L", "XL", "XXL"] 
  stock           Int      @default(0)
  category        String?  // "T-Shirts", "Mugs", "Accessories"
  isActive        Boolean  @default(true)
  
  // Admin tracking
  createdBy       String
  creator         User     @relation("MerchandiseCreator", fields: [createdBy], references: [id])
  
  // Relations
  orderItems      MerchandiseOrderItem[]
  cartItems       MerchandiseCartItem[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([category])
  @@index([isActive])
  @@map("merchandise")
}

model MerchandiseOrder {
  id               String   @id @default(cuid())
  orderNumber      String   @unique // "ORD-2025-001"
  userId           String
  user             User     @relation("MerchandiseOrders", fields: [userId], references: [id])
  
  // Order details
  totalAmount      Decimal  @db.Decimal(10, 2)
  status           String   @default("PENDING") // PENDING, CONFIRMED, DELIVERED, CANCELLED
  
  // Payment information
  paymentTransactionId String?
  paymentTransaction   PaymentTransaction? @relation("MerchandisePayments", fields: [paymentTransactionId], references: [id])
  paymentStatus        String   @default("PENDING") // PENDING, COMPLETED, FAILED
  
  // Delivery information  
  deliveryStatus   String   @default("PENDING") // PENDING, SHIPPED, DELIVERED
  deliveredBy      String?
  deliveredAt      DateTime?
  deliveryNotes    String?
  
  // QR Code for order tracking
  qrCode           String?  @unique
  qrData           Json?    // QR code data
  
  // Relations
  items            MerchandiseOrderItem[]
  
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  
  @@index([userId])
  @@index([orderNumber])
  @@index([status])
  @@index([deliveryStatus])
  @@map("merchandise_orders")
}

model MerchandiseOrderItem {
  id               String   @id @default(cuid())
  orderId          String
  order            MerchandiseOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  merchandiseId    String
  merchandise      Merchandise @relation(fields: [merchandiseId], references: [id])
  
  quantity         Int
  selectedSize     String?
  unitPrice        Decimal  @db.Decimal(10, 2)
  totalPrice       Decimal  @db.Decimal(10, 2)
  
  createdAt        DateTime @default(now())
  
  @@index([orderId])
  @@index([merchandiseId])
  @@map("merchandise_order_items")
}

model MerchandiseCartItem {
  id               String   @id @default(cuid())
  userId           String
  user             User     @relation("MerchandiseCart", fields: [userId], references: [id])
  merchandiseId    String
  merchandise      Merchandise @relation(fields: [merchandiseId], references: [id])
  
  quantity         Int
  selectedSize     String?
  
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  
  @@unique([userId, merchandiseId, selectedSize])
  @@index([userId])
  @@map("merchandise_cart_items")
}

// Single Festival table - stores all festival data
model Festival {
  id                String            @id @default(cuid())
  name              String            @unique
  description       String?
  date              DateTime
  
  // Festival categorization
  festivalType      FestivalType
  religion          Religion?
  region            String?
  
  // Visual styling (Keka.com style)
  vectorImage       String?           // SVG/vector image URL
  backgroundColor   String            @default("#f8f9fa")
  textColor         String            @default("#333333")
  greetingMessage   String?
  
  // Configuration
  priority          FestivalPriority  @default(MAJOR)
  isActive          Boolean           @default(true)
  enableNotifications Boolean         @default(true)
  
  // API source tracking
  externalId        String?           // External API festival ID
  source            String            @default("INTERNAL") // INTERNAL, CALENDARIFIC, MANUAL
  lastSyncedAt      DateTime?
  
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  
  @@index([date])
  @@index([festivalType])
  @@index([isActive])
  @@index([priority])
  @@index([enableNotifications])
  @@map("festivals")
}



// Enums
enum UserRole {
  USER
  BATCH_ADMIN
  SUPER_ADMIN
}

enum PostCategory {
  MOM         // Minutes of Meeting
  STORY       // Alumni Story
  POST        // General Post
  NOTICE     // Official Notice
  ANNOUNCEMENT // Event Announcement
}

enum AttendeeStatus {
  PENDING
  CONFIRMED
  DECLINED
}

enum TransactionType {
  COLLECTION  // Money coming in (donations, fees)
  EXPENSE     // Money going out
}

enum TransactionStatus {
  PENDING
  APPROVED
  REJECTED
  COMPLETED
}

enum NotificationType {
  MENTION
  COMMENT_REPLY
  POST_APPROVED
  EVENT_INVITATION
  PAYMENT_RECEIVED
  GENERAL
  BIRTHDAY_NOTIFICATION
  FESTIVAL_NOTIFICATION

}

enum EmploymentStatus {
  WORKING
  STUDYING
  OPEN_TO_WORK
  ENTREPRENEUR
  RETIRED
}

enum CompanyType {
  GOVERNMENT
  PRIVATE
  STARTUP
  NGO
  FREELANCE
  SELF_EMPLOYED
}

enum AddressType {
  PERMANENT
  CURRENT
}

enum EventMode {
  PHYSICAL
  VIRTUAL
  HYBRID
}

enum EventStatus {
  DRAFT
  PUBLISHED
  REGISTRATION_OPEN
  REGISTRATION_CLOSED
  ONGOING
  COMPLETED
  CANCELLED
  ARCHIVED
}

enum EventSectionType {
  SCHEDULE
  ORGANIZERS
  LOCATION
  PRIZES
  SPONSORS
  DONATIONS
  MERCHANDISE
  CUSTOM
}

enum EventFormFieldType {
  TEXT
  EMAIL
  PHONE
  TEXTAREA
  SELECT
  RADIO
  CHECKBOX
  FILE
  RATING
  LIKERT
  SENTIMENT
}

enum FeedbackResponseStatus {
  DRAFT
  SUBMITTED
  REVIEWED
}

enum SentimentScore {
  VERY_NEGATIVE
  NEGATIVE
  NEUTRAL
  POSITIVE
  VERY_POSITIVE
}

enum EventRegistrationStatus {
  CONFIRMED
  CANCELLED
  WAITLIST
}


enum MealPreference {
  VEG
  NON_VEG
}

enum GuestStatus {
  ACTIVE
  CANCELLED
}

enum PaymentProvider {
  RAZORPAY
  PAYTM
  PHONEPE
  STRIPE
}

enum PaymentReferenceType {
  EVENT_REGISTRATION    // Full event registration payment
  MERCHANDISE          // Merchandise only payment
  GUEST_FEES          // Guest fees only payment
  ADDITIONAL_FEES     // Any additional fees
  DONATION           // Donation payment
  MEMBERSHIP              // NEW
  BATCH_ADMIN_PAYMENT
  MERCHANDISE_PAYMENT
  MERCHANDISE_ORDER
}

enum PaymentStatus {
  PENDING            // Payment initiated but not completed
  PROCESSING         // Payment in progress
  COMPLETED          // Payment successful
  FAILED             // Payment failed
  CANCELLED          // Payment cancelled by user
  REFUNDED           // Payment refunded
  PARTIALLY_REFUNDED // Partial refund processed
  EXPIRED            // Payment link expired
}

enum WebhookStatus {
  RECEIVED           // Webhook received
  VERIFIED           // Signature verified
  PROCESSED          // Successfully processed
  FAILED             // Processing failed
  IGNORED            // Ignored (duplicate or irrelevant)
}

enum InvoiceStatus {
  PENDING            // Invoice not yet generated
  GENERATED          // Invoice generated
  EMAILED            // Invoice sent via email
  FAILED             // Invoice generation failed
}

enum CheckInMethod {
  QR_CODE
  MANUAL
  BULK_IMPORT
  API
}

enum DeliveryStatus {
  PENDING
  IN_TRANSIT
  DELIVERED
  FAILED
  RETURNED
}

// ============================================
// ENUMS FOR TREASURY SYSTEM
// ============================================

enum ManualCollectionMode {
  CASH
  CHEQUE
  BANK_TRANSFER
  UPI_OFFLINE
  OTHER
}

enum GroupType {
  CELL
  COMMITTEE  
  OFFICE_BEARERS
  ADVISORS
}

enum GroupMemberRole {
  // Cell/Committee Roles
  CONVENER
  CO_CONVENER
  STAKE_HOLDER
  
  // Office Bearer Roles
  PRESIDENT
  VICE_PRESIDENT
  SECRETARY
  JOINT_SECRETARY
  TREASURER
  JOINT_TREASURER
  
  // Advisor Roles
  CHIEF_ADVISOR
  JOINT_ADVISOR
}

enum SponsorCategory {
  GOLD
  SILVER
  BRONZE
}

// LifeLink enums

enum BloodGroup {
  A_POSITIVE
  A_NEGATIVE
  B_POSITIVE
  B_NEGATIVE
  AB_POSITIVE
  AB_NEGATIVE
  O_POSITIVE
  O_NEGATIVE

  @@map("blood_groups")
}

enum RequisitionStatus {
  ACTIVE
  FULFILLED
  EXPIRED
  CANCELLED

  @@map("requisition_statuses")
}

enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  READ
  EXPIRED

  @@map("notification_statuses")
}

enum DonorResponseStatus {
  WILLING
  NOT_AVAILABLE
  NOT_SUITABLE
  NO_RESPONSE

  @@map("donor_response_statuses")
}

// Ticket Enums

enum TicketStatus {
  OPEN           // Just created, waiting for admin response
  IN_PROGRESS    // Admin is working on it
  WAITING_FOR_USER // Admin responded, waiting for user reply
  RESOLVED       // Admin marked as resolved
  CLOSED         // Ticket is closed (by admin or auto-closed)
  REOPENED       // User reopened a closed/resolved ticket
}

enum TicketPriority {
  LOW     // General questions, non-urgent
  MEDIUM  // Default priority
  HIGH    // Important issues affecting user experience
  URGENT  // Critical issues requiring immediate attention
}

enum TicketSatisfaction {
  VERY_SATISFIED
  SATISFIED
  NEUTRAL
  DISSATISFIED
  VERY_DISSATISFIED
}

enum MessageReactionType {
  HELPFUL
  SOLVED  
  NEEDS_CLARIFICATION
  THUMBS_UP
  THUMBS_DOWN
}

enum AuditActionType {
  CREATED
  STATUS_CHANGED
  PRIORITY_CHANGED
  CATEGORY_CHANGED
  ASSIGNED
  REASSIGNED
  MESSAGE_ADDED
  MESSAGE_EDITED
  MESSAGE_REACTION_ADDED
  ATTACHMENT_ADDED
  ATTACHMENT_REMOVED
  SATISFACTION_RATED
  REOPENED
  CLOSED
  BULK_OPERATION
}

enum MessageContentType {
  PLAIN_TEXT
  RICH_TEXT
  HTML
}

enum BulkOperationType {
  ASSIGN_TO_ADMIN
  CHANGE_STATUS
  CHANGE_PRIORITY
  CHANGE_CATEGORY
  CLOSE_WITH_RESOLUTION
  ADD_TAG
  EXPORT_SELECTED
}

enum BulkOperationStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
  PARTIALLY_COMPLETED
}

enum SearchType {
  BASIC       // Simple text search
  ADVANCED    // Complex filters
  FILTER_PRESET // Using saved filter
}

enum MembershipStatus {
  ACTIVE      // Paid and valid
  EXPIRED     // Membership period ended
  PENDING     // Payment initiated but not completed
  SUSPENDED   // Admin suspended
  INACTIVE    // Never paid or deactivated
}

enum RegistrationMode {
  INDIVIDUAL           // Normal individual registration
  BATCH_COLLECTION     // Batch collection system active
  MIXED               // Both modes allowed (future feature)
  DISABLED            // Registration disabled
}

// ENUMS FOR CELEBRATION SYSTEM
// ============================================

enum FestivalType {
  NATIONAL_HOLIDAY
  HINDU
  MUSLIM
  CHRISTIAN
  SIKH
  BUDDHIST
  JAIN
  REGIONAL
  CULTURAL
}

enum Religion {
  HINDUISM
  ISLAM
  CHRISTIANITY
  SIKHISM
  BUDDHISM
  JAINISM
  OTHER
}

enum FestivalPriority {
  MAJOR      // Major festivals like Diwali, Holi, Eid
  REGIONAL   // Regional festivals
  MINOR      // Minor festivals
}